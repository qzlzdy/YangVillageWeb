{{{#!comment
    YangVillage Website
    Copyright (C) 2024  Qzlzdy

    This content is licensed under the Creative Commons Attribution Share Alike
    4.0 International (CC-BY-SA-4.0).

    See <https://creativecommons.org/licenses/by-sa/4.0/>.
}}}
[[PageOutline]]

= 1. mesy指令集架构

 原型:: [https://riscv.org/technical/specifications/ RISC-V]

设计指令集架构是建造红石计算机的第一步，它是计算机硬件系统设计的依据。mesy指令集是基于RISC-V针对红石计算机的设计目标进行修改后的指令集。为了减少红石计算机的建造工程量及设计复杂度，mesy指令集删除了较少使用的特性，只保留基础功能。

mesy指令集的目标：

- mesy不使用扩展，由组代替扩展。所有mesy中的组都是必选，对应原`IMAFDZicsr`扩展的内容。
- mesy只支持[[math(32)]]位地址空间。
- mesy只支持单核、单处理器。
- mesy没有可变长指令，指令固定为[[math(32)]]位。

本文主要介绍非特权级架构，特权级架构[../MesyPriv 参阅此处]

== 1.1. 内存

mesy有一块[[math(2^{32}B)]]的内存空间。一个//字//对应[[math(32)]]位；一个//半字//对应[[math(16)]]位；一个//双字//对应[[math(64)]]位。内存空间是循环的，即[[math(2^{31}-1)]]地址与[[math(0)]]地址相邻。

== 1.2. 指令长度编码

mesy的指令长度固定为[[math(32)]]位，必须自然对齐。指令位全为[[math(0)]]或全为[[math(1)]]的都是非法指令。

== 1.3. 异常、陷阱和中断

//异常//指运行时出现的与当前指令相关的异常情况。//中断//指可能导致意外控制转移的外部异步事件。//陷阱//指由异常或中断导致的向服务程序的控制转移。

= 2. 基础整数指令组

== 2.1. 编程模型

mesy的基础整数指令组中有32个[[math(32)]]位通用寄存器`x0-x31`，以及一个非特权寄存器——程序计数器`pc`。其中`x0`硬编码为[[math(0)]]，`pc`记录当前指令的地址。

== 2.2. 指令格式

mesy的指令格式分为6类。所有格式的指令总是[[math(32)]]位，必须自然对齐。源寄存器`rs1`、`rs2`，目的寄存器`rd`在所有格式中的位置保持一致。除CSR指令的立即数以外，所有立即数使用符号扩展。立即数的符号位总是指令中的最高位。

[[Image(InstructionFormats.png)]]

立即数在指令中编码的原则遵循最大重叠规则。

[[Image(ImmediateFormats.png)]]

== 2.3. 整数计算指令

=== 2.3.1. RI指令

[[Image(IntegerRegImmArith.png)]]

`ADDI`计算立即数与[[math(rs1)]]的合，结果存入[[math(rd)]]。

`SLTI`做有符号比较，当[[math(rs1)]]小于立即数时[[math(rd)]]置[[math(1)]]。`SLTIU`与`SLTI`相似，但做无符号比较。

`ANDI`，`ORI`，`XORI`分别做位与，位或，位异或运算，结果存入[[math(rd)]]。

[[Image(IntegerRegImmShift.png)]]

立即数移位指令编码为I型，偏移量编码在立即数低[[math(5)]]位。右移位的类型编码在第[[math(30)]]位。`SLLI`做逻辑左移；`SRLI`做逻辑右移；`SRAI`做算术右移。

[[Image(IntegerRegImmUpper.png)]]

`LUI`将立即数存入[[math(rd)]]高[[math(20)]]位，并在低[[math(12)]]位填[[math(0)]]。

`AUIPC`将立即数作为偏移量高[[math(20)]]位，计算相对[[math(pc)]]的偏移地址，结果存入[[math(rd)]]。

{{{#!box details
`AUIPC`使用的[[math(pc)]]值实际上是紧跟`AUIPC`后一条指令的地址，即[[math(pc+4)]]。
}}}

=== 2.3.2. RR指令

所有整数RR指令的源寄存器为`rs1`和`rs2`，目的寄存器是`rd`。`func7`和`func3`字段表示指令的操作类型。

[[Image(IntegerRegReg.png)]]

`ADD`计算[[math(rs1)]]和[[math(rs2)]]的合。`SUB`计算[[math(rs1)]]与[[math(rs2)]]的差。`SLT`和`SLTU`分别做有符号和无符号比较，当[[math(rs1)]]小于[[math(rs2)]]时[[math(rd)]]置[[math(1)]]。`AND`，`OR`和`XOR`分别做位与，位或和位异或运算。

`SLL`，`SRL`和`SRA`分别做逻辑左移，逻辑右移，算术右移运算，偏移量取[[math(rs2)]]的低[[math(5)]]位。

=== 2.3.3. NOP指令

[[Image(NopInstruction.png)]]

NOP指令即空指令，仅修改[[math(pc)]]和启用的计数器的值。

== 2.4. 控制转移指令

mesy提供两类控制转移指令：无条件跳转和条件分支。mesy中没有延迟槽

=== 2.4.1. 无条件跳转

`JAL`可以寻址[[math(\pm2MB)]]的空间，并把紧跟的指令地址，即[[math(pc+4)]]存入[[math(rd)]]。

[[Image(JumpAndLink.png)]]

`JALR`通过基址寻址，并把紧跟的指令地址，即[[math(pc+4)]]存入[[math(rd)]]。

[[Image(JumpAndLinkRegister.png)]]

=== 2.4.2. 条件分支

条件分支的寻址范围是[[math(\pm8KB)]]。

[[Image(ConditionalBranches.png)]]

`BEQ`，`BNE`分别在[[math(rs1)]]和[[math(rs2)]]相等，不相等时跳转。`BLT`，`BLTU`分别在有符号，无符号情况下[[math(rs1)]]小于[[math(rs2)]]时跳转。`BGE`，`BGEU`分别在有符号，无符号情况下[[math(rs1)]]大于等于[[math(rs2)]]时跳转。

== 2.5. 载入和储存指令

mesy固定使用小端格式。

[[Image(LoadInstructions.png)]]

[[Image(StoreInstructions.png)]]

载入和储存指令在寄存器与内存之间传输数据。载入指令将内存中的值拷贝到寄存器。储存指令将寄存器中的值拷贝到内存。

`LW`载入[[math(32)]]位数据。`LH`载入[[math(16)]]位有符号数据。`LHU`载入[[math(16)]]位无符号数据。`LB`载入[[math(8)]]位有符号数据。`LBU`载入[[math(8)]]位无符号数据。`SW`，`SH`，`SB`分别储存[[math(32)]]位，[[math(16)]]位，[[math(8)]]位数据。

载入和存储指令只支持地址自然对齐。

== 2.6. 环境调用

`SYSTEM`指令用于访问需要特权级的系统功能。这些指令分为两大类：原子读写CSR的指令和其他指令。

[[Image(EnvironmentCall.png)]]

`ECALL`用于调用执行环境的服务。

= 3. 整数乘除指令组(M)

== 3.1. 乘法运算

[[Image(Multiplication.png)]]

`MUL`做有符号乘法运算，取低c位结果。`MULH`，`MULHU`，`MULHSU`分别做有符号，无符号，混合符号乘法运算，取高[[math(32)]]位结果。

== 3.2. 除法运算

[[Image(Division.png)]]

`DIV`，`DIVU`分别做有符号，无符号除法运算，结果取商，向零取整。`REM`，`REMU`分别作有符号，无符号除法运算，结果取余数。余数的符号与被除数的符号相同。

||=条件=||=被除数=||=除数=||=DIVU=||=REMU=||=DIV=||=REM=||
||除数为零 || [[math(x)]] || [[math(0)]] || [[math(2^L-1)]] || [[math(1)]] || [[math(-1)]] || [[math(x)]] ||
||除法溢出 || [[math(-2^{L-1})]] || [[math(-1)]] || [[math(-)]] || [[math(-)]] || [[math(-2^{L-1})]] || [[math(0)]] ||

= 4. 原子指令组(A)

= 5. 控制状态寄存器指令组(Zicsr)

mesy定义了一个分离的地址空间，包含4096个CSR。

== 5.1. CSR指令

CSR指令对一个CSR做原子读写。CSR地址在指令高[[math(12)]]位编码。立即数在`rs1`字段编码，做无符号扩展。

[[Image(CsrInstructions.png)]]

`CSRRW`原子交换CSR与寄存器中的值。该指令读取CSR中的值存入[[math(rd)]]，并将[[math(rs1)]]写入CSR。

`CSRRS`读取CSR的值存入[[math(rd)]]，并以[[math(rs1)]]为掩码将CSR置[[math(1)]]。

`CSRRC`读取CSR的值存入[[math(rd)]]，并以[[math(rs1)]]为掩码将CSR置[[math(0)]]。

`CSRRWI`，`CSRRSI`和`CSRRCI`与`CSRRW`，`CSRRS`和`CSRRC`相似，但用无符号立即数代替[[math(rs1)]]。

= 6. 计数器

== 6.1. 基础计数器和计时器

[[Image(CountersAndTimers.png)]]

mesy提供了数个[[math(64)]]位只读用户态计数器。

`RDCYCLE`和`RDCYCLEH`分别读取`cycle`的低[[math(32)]]位和高[[math(32)]]位。`cycle`计数器在每个机器周期自增。

`RDINSTRET`和`RDINSTRETH`分别读取`instret`的低[[math(32)]]位和高[[math(32)]]位。

> 读取64位计数器的示例代码
>
> {{{#!c
> again:
>     rdcycleh    $3
>     rdcycle     $2
>     rdcycleh    $4
>     bne         $3, $4, again
> }}}

= 7. 单精度浮点数指令组(F)

= 8. mesy指令集列表

**mesy编码表**，[[math(instr[1:0]=11)]]。

[[Image(OpcodeMap.png)]]

**基础指令组**

[[Image(IntegerGroup.png)]]

**Zicsr指令组**

[[Image(ZicsrGroup.png)]]

**M指令组**

[[Image(MulDivGroup.png)]]

**A指令组**

[[Image(AtomicGroup.png)]]

**F指令组**

[[Image(FloatGroup.png)]]

= 9. 汇编手册

**汇编寄存器助记符**

||= 寄存器 =||= 别名 =||= 描述 =||= 保存方 =||
||[[math(x0)]] ||[[math(zero)]] ||硬编码到[[math(0)]] || [[math(-)]] ||
||[[math(x1)]] ||[[math(ra)]] ||返回地址 || 调用者 ||
||[[math(x2)]] ||[[math(sp)]] ||栈指针 || 被调用者 ||
||[[math(x3)]] ||[[math(gp)]] ||全局指针 || [[math(-)]] ||
||[[math(x4)]] ||[[math(tp)]] ||线程指针 || [[math(-)]] ||
||[[math(x5)]] ||[[math(t0)]] ||临时链接 || 调用者 ||
||[[math(x6-7)]] ||[[math(t1-2)]] ||临时 || 调用者 ||
||[[math(x8)]] ||[[math(s0/fp)]] ||非临时/页框指针 || 被调用者 ||
||[[math(x9)]] ||[[math(s1)]] ||非临时 || 被调用者 ||
||[[math(x10-11)]] ||[[math(a0-1)]] ||函数参数/返回值 || 调用者 ||
||[[math(x12-17)]] ||[[math(a2-7)]] ||函数参数 || 调用者 ||
||[[math(x18-27)]] ||[[math(s2-11)]] ||非临时 || 被调用者 ||
||[[math(x28-31)]] ||[[math(t3-6)]] ||临时 || 调用者 ||

**汇编伪指令**

||= 伪指令 =||= 基础指令 =||= 语义 =||
||`l{b,h,w} rd, symbol` ||`auipc rd, delta[31:12] + delta[11]`[[BR]]`l{b,h,w} rd, delta[11:0]` ||全局加载 ||
||`s{b,h,w} rd, symbol, rt` ||`auipc rt, delta[31:12] + delta[11]`[[BR]]`s{b,h,w} rd, delta[11:0](rt)` ||全局储存 ||
||`nop` ||`addi $0, $0, 0` ||空指令 ||
||`li rd, immediate` ||多条指令序列 ||加载立即数 ||
||`mv rd, rs` ||`addi rd, rs, 0` ||复制 ||
||`not rd, rs` ||`xori rd, rs, -1` ||位非 ||
||`neg rd, rs` ||`sub rd, $0, rs` ||相反数 ||
||`seqz rd, rs` ||`sltiu rd, rs, 1` ||[[math(rs=0)]]时置[[math(1)]] ||
||`snez rd, rs` ||`sltu rd, $0, rs` ||[[math(rs\neq0)]]时置[[math(1)]] ||
||`sltz rd, rs` ||`slt rd, rs, $0` ||[[math(rs<0)]]时置[[math(1)]] ||
||`sgtz rd, rs` ||`slt rd, $0, rs` ||[[math(rs>0)]]时置[[math(1)]] ||
||`beqz rs, offset` ||`beq rs, $0, offset` ||[[math(rs=0)]]时跳转 ||
||`bnez rs, offset` ||`bne rs, $0, offset` ||[[math(rs\neq0)]]时跳转 ||
||`blez rs, offset` ||`bge $0, rs, offset` ||[[math(rs\le0)]]时跳转 ||
||`bgez rs, offset` ||`bge rs, $0, offset` ||[[math(rs\ge0)]]时跳转 ||
||`bltz rs, offset` ||`blt rs, $0, offset` ||[[math(rs<0)]]时跳转 ||
||`bgtz rs, offset` ||`blt $0, rs, offset` ||[[math(rs>0)]]时跳转 ||
||`bgt rs, rt, offset` ||`blt rt, rs, offset` ||大于时跳转 ||
||`ble rs, rt, offset` ||`bge rt, rs, offset` ||小于等于时跳转 ||
||`bgtu rs, rt, offset` ||`bltu rt, rs, offset` ||大于时跳转（无符号） ||
||`bleu rs, rt, offset` ||`bgeu rt, rs, offset` ||小于等于时跳转（无符号） ||
||`j offset` ||`jal $0, offset` ||只跳转 ||
||`jal offset` ||`jal $1, offset` ||跳转并链接 ||
||`jr rs` ||`jalr $0, 0(rs)` ||跳转寄存器 ||
||`jalr rs` ||`jalr $1, 0(rs)` ||跳转寄存器并链接 ||
||`ret` ||`jalr $0, 0($1)` ||返回 ||
||`call offset` ||`auipc $1, offset[31:12] + offset[11]`[[BR]]`jalr $1, offset[11:0]($1)` ||调用 ||
||`tail offset` ||`auipc $6, offset[31:12] + offset[11]`[[BR]]`jalr $0, offset[11:0]($6)` ||尾调用 ||
||`rdinstret[h] rd` ||`csrrs rd, instret[h], $0` ||读[[math(instret)]] ||
||`rdcycle[h] rd` ||`csrrs rd, cycle[h], $0` ||读[[math(cycle)]] ||
||`csrr rd, csr` ||`csrrs rd, csr, $0` ||读CSR ||
||`csrw csr, rs` ||`csrrw $0, csr, rs` ||写CSR ||
||`csrs csr, rs` ||`csrrs $0, csr, rs` ||CSR置[[math(1)]] ||
||`csrc csr, rs` ||`csrrc $0, csr, rs` ||CSR置[[math(0)]] ||
||`csrwi csr, imm` ||`csrwi $0, csr, imm` ||写CSR（立即数） ||
||`csrsi csr, imm` ||`csrrsi $0, csr, imm` ||CSR置[[math(1)]]（立即数） ||
||`csrci csr, imm` ||`csrrci $0, csr, imm` ||CSR置[[math(0)]]（立即数） ||
