---
title: ylikou处理器
---

- [1. ylikou处理器](#1-ylikou处理器)
- [2. 实现规范](#2-实现规范)
  - [2.1. 允许使用的运算符](#21-允许使用的运算符)
    - [2.1.1. 基本门电路](#211-基本门电路)
    - [2.1.2. 规约运算符](#212-规约运算符)
    - [2.1.3. 比较运算符](#213-比较运算符)
    - [2.1.4. 其他运算符](#214-其他运算符)
  - [2.2. 允许使用的模块](#22-允许使用的模块)
    - [2.2.1. 寄存器](#221-寄存器)
    - [2.2.2. 数据选择器](#222-数据选择器)
    - [2.2.3. 位操作模块](#223-位操作模块)
    - [2.2.4. 存储器](#224-存储器)
    - [2.2.5. 工程提供的模块](#225-工程提供的模块)
    - [2.2.6. 其他模块](#226-其他模块)
- [3. 流水线](#3-流水线)
  - [3.1. 取指](#31-取指)
  - [3.2. 执行](#32-执行)
    - [3.2.1. 译码](#321-译码)
    - [3.2.2. 寄存器组](#322-寄存器组)
    - [3.2.3. ALU](#323-alu)
      - [3.2.3.1. 加法器](#3231-加法器)
      - [3.2.3.2. 移位器](#3232-移位器)
    - [3.2.4. 分支判断单元](#324-分支判断单元)
  - [3.3. 写回](#33-写回)
  - [3.4. 访存](#34-访存)
    - [3.4.1. CSR单元](#341-csr单元)
- [4. 缓存](#4-缓存)
  - [4.1. 存储单元](#41-存储单元)
  - [4.2. 控制单元](#42-控制单元)
    - [4.2.1. CPU读写请求控制流程](#421-cpu读写请求控制流程)
    - [4.2.2. Miss单元replace请求控制流程](#422-miss单元replace请求控制流程)
    - [4.2.3. Probe单元probe请求控制流程](#423-probe单元probe请求控制流程)
  - [4.3. Probe单元](#43-probe单元)
  - [4.4. Miss单元](#44-miss单元)
  - [4.5. 重填单元](#45-重填单元)
  - [4.6. Release单元](#46-release单元)

# 1. ylikou处理器

原型：[riscv-mini][1]、[Xiangshan][2]、[e203_hbirdv2][3]

实现语言：[Chisel3](https://www.chisel-lang.org/)

[1]: https://github.com/ucb-bar/riscv-mini.git
[2]: https://github.com/OpenXiangShan/XiangShan.git
[3]: https://github.com/riscv-mcu/e203_hbirdv2

---

ylikou处理器是mesy ISA在本工程的实现。主要部分原型是[`ucb-bar/riscv-mini`][1]，但也参考了[`OpenXiangShan/XiangShan`][2]的Cache实现和[`riscv-mcu/e203_hbirdv2`][3]的译码器实现。

ylikou与[riscv-mini][1]一样是三段流水线设计，即取指，执行，写回三个阶段。ylikou在执行分支、访存指令时，通过插入空泡阻塞流水线。ylikou的Cache只有L1级，且使用哈佛结构，Cache与内存通过[syndesmos协议](../syndesmos)交互。

# 2. 实现规范

ylikou使用Chisel3库实现。但ylikou尽量不使用标准库的内建硬件模块，因为ylikou最终需要用红石电路实现，即精确到门级建模。本章给出一些在实现中允许使用的运算符和模块，以及其门级实现（如果有的话）。

## 2.1. 允许使用的运算符

### 2.1.1. 基本门电路

所有的硬件电路最终都需要使用基本门电路实现。本工程中允许使用的门包括与门`&`、或门`|`、非门`~`和异或门`^`。

!!! 尽管理论上最少只用一种门就可以具备图灵完备性，但为了实现简单，工程选用了上述四种常用的逻辑门做为最小的电路单元。

### 2.1.2. 规约运算符

规约操作实际上就是将数据中的所有位做为单一基本门电路的输入，产生$1$位结果。本工程中允许使用的规约操作有`andR`，`orR`和`xorR`。

### 2.1.3. 比较运算符

本工程中允许使用的比较运算符有`===`和`=/=`。

|运算符|门级实现|描述|
|:--|:--|:--|
|`a === b`|`~|(a ^ b)`|相等|
|`a =/= b`|`|(a ^ b)`|不相等|

### 2.1.4. 其他运算符

除了上述允许使用的运算符以外，其他运算符均因为不同的原因**不允许**使用。

- 算术操作`+`，`-`，`*`，`/`和`%`需要专用的运算部件
- 移位操作`<<`，`>>`需要移位器
- 比较操作`<`，`>`，`<=`和`>=`需要算术运算

## 2.2. 允许使用的模块

### 2.2.1. 寄存器

寄存器是时序数字电路的基础。因此，工程将寄存器作为基本的电路模块，包括所有`Reg*`模块。

### 2.2.2. 数据选择器

基本的数据选择器`Mux`在工程中作为基本模块使用。为了编码方便，工程也允许使用`MuxCase`，`MuxLookup`和`PriorityMux`等可传入`Seq`类型信号的数据选择器变种。

仲裁器`Arbiter`本质上也是一种优先级数据选择器，因此也允许使用。

### 2.2.3. 位操作模块

工程允许使用`Fill`，`Cat`，`Reverse`等可以直接通过连线实现的函数。当数据宽度不大（$\le4$）时，允许使用`UIntToOH`等编码转换模块。

### 2.2.4. 存储器

存储器在红石电路中可以实现为寄存器阵列。工程允许使用同步读存储器`SyncReadMem`和异步读存储器`Mem`。

### 2.2.5. 工程提供的模块

本工程中提供了若干标准库替换模块。

|模块|描述|
|:--|:--|
|`plus1`|加$1$。用于计数器的实现，包括程序计数器`PC`|
|`Counter`|计数器。对于数据宽度低于$4$位的计数可以使用标准库|

### 2.2.6. 其他模块

除了上述允许使用的模块以外，其他模块**不允许**直接使用。

# 3. 流水线

## 3.1. 取指

ylikou的取指阶段包括以下步骤：

1. 取指目标生成器根据当前机器状态选择指令地址，取指目标来源一般有：
   - $pc+4$（绝大部分情况）
   - $pc$（插入空泡）
   - $tvec$（发生陷阱时）
   - $epc$（陷阱返回时）
   - $ALU$（跳转时）
2. 将取指目标传输至`L1i`，同时更新$pc$。指令将在下一阶段返回

$pc+4$的计算使用额外的自增器，不占用ALU。

## 3.2. 执行

ylikou在执行阶段完成了尽可能多的工作。这些工作都通过组合逻辑电路实现：

1. 指令从`L1i`返回，进行译码
2. 根据寄存器地址读源寄存器，或根据指令提取立即数
3. 根据源寄存器地址检测数据冒险。若存在冒险则使用旁路数据
4. 根据指令进行相应计算：
   - `ALU`计算，包括普通计算指令、控制转移地址计算、访存地址计算等
   - 分支条件判断

### 3.2.1. 译码

译码器根据指令产生内部控制信号，采用组合逻辑实现。立即数的提取也在该环节完成。

### 3.2.2. 寄存器组

ylikou包含32个$32$位通用整数寄存器，具有两个读端口和一个写端口。三个端口可以同时工作。当读写端口访问同一个地址时，读端口读取的数据为写之前的原始数据，写端口的新数据在下一个始终上升沿写入。

### 3.2.3. ALU

ALU负责了大部分指令的计算任务，包括：

- 算术、逻辑、移位运算
- 访存地址计算
- 跳转地址计算

#### 3.2.3.1. 加法器

加法器的实现采用了并行进位技术。每$4$位为一组，嵌套两层并行进位器。低$16$位与高$16$之间采用串行进位。加法器的输入端有反相器，配合进位输入实现减法。对于比较运算，只需在减法的基础上判断输入符号位与溢出标志位即可。

#### 3.2.3.2. 移位器

移位器实现了右移位，采用桶式移位器，在一个时钟周期内完成最多$31$位移位。对于左移位，只需将输入端和输出端的高低位倒转。

### 3.2.4. 分支判断单元

分支判断单元负责判断分支是否需要执行，判断过程与分支地址的计算同时进行。地址计算占用了ALU，因此分支判断单元使用一个额外的加法器做减法，再根据指令的分支类型输出最终结果。

## 3.3. 写回

ylikou的写回阶段比较简单，只需根据指令选择数据源写入寄存器。此处有一条数据旁路通向`ALU`。

## 3.4. 访存

访存阶段是在执行访存指令或CSR指令时产生的额外的流水线阶段，插入在执行阶段后，写回阶段前。访存地址的计算，数据格式的调整都在执行阶段完成，而访存阶段主要负责读出数据的处理，即根据访存地址和数据长度调整数据格式。CSR指令也在该阶段被送入CSR单元执行。

### 3.4.1. CSR单元

CSR单元负责执行CSR指令，所有的CSR都在该单元中。

# 4. 缓存

ylikou只有一级Cache，采用哈佛结构。每个Cache均为$4KB$，采用直接映射，块大小$16B$。

Cache内部分为多个执行单元，负责实现不同的任务。每个执行单元使用状态机实现。

## 4.1. 存储单元

实际存储数据及元数据的组件。数据存储单元为$4KB$，分为$16$体。元数据包括$20$位`tag`，$2$位权限位和$1$位脏位。

## 4.2. 控制单元

控制单元实现了主要的控制逻辑。控制单元的请求源按优先级由高到低排序分别是Probe单元，Miss单元和CPU。所有请求都需要读取存储单元。随后，控制单元根据命中情况向不同的执行单元发送请求。

### 4.2.1. CPU读写请求控制流程

1. 控制单元接受请求，读存储单元
2. 根据命中情况执行不同操作：
   - 命中。直接返回读出的数据，流程结束
   - 不命中。向Miss单元发送不命中请求
3. Miss单元向CPU返回新数据

### 4.2.2. Miss单元replace请求控制流程

1. 控制单元接受请求，读存储单元
2. 向Release单元发送`replace`请求
3. 向Miss单元发送应答

### 4.2.3. Probe单元probe请求控制流程

1. 控制单元接受请求，读存储单元
2. 修改元数据标识位
3. 向Release单元发送`probe`请求

## 4.3. Probe单元

Probe单元接受来自B通道的`probe`请求，并将协议请求翻译为Cache内部请求，发送至控制单元。

## 4.4. Miss单元

Miss单元接受来自控制单元的不命中请求。发生不命中时，Miss单元向下级发送`acquire`请求获取新数据。若有需要替换的脏数据，则向控制单元发送`replace`请求。当所有请求的操作完成后，Miss单元向重填单元发送重填请求。

## 4.5. 重填单元

重填单元负责将从Miss单元返回的新数据重填至存储单元。重填时可能与控制单元发生冲突，此时重填具有更高优先级。

## 4.6. Release单元

Release单元负责接受内部的`probe`和`replace`请求，将相应脏数据通过协议写回下级存储器。
