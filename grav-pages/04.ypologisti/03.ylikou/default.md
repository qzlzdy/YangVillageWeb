---
title: ylikou处理器
---

- [1. ylikou处理器](#1-ylikou处理器)
- [2. 取指](#2-取指)
- [3. 执行](#3-执行)
- [4. 写回](#4-写回)
- [5. 访存](#5-访存)
- [6. 缓存](#6-缓存)
  - [6.1. 存储单元](#61-存储单元)
  - [6.2. 控制单元](#62-控制单元)
    - [6.2.1. CPU读写请求控制流程](#621-cpu读写请求控制流程)
    - [6.2.2. Miss单元replace请求控制流程](#622-miss单元replace请求控制流程)
    - [6.2.3. Probe单元probe请求控制流程](#623-probe单元probe请求控制流程)
  - [6.3. Probe单元](#63-probe单元)
  - [6.4. Miss单元](#64-miss单元)
  - [6.5. 重填单元](#65-重填单元)
  - [6.6. Release单元](#66-release单元)

# 1. ylikou处理器

原型：[riscv-mini][1] [Xiangshan][2]
实现语言：[Chisel3](https://www.chisel-lang.org/)

[1]: https://github.com/ucb-bar/riscv-mini.git
[2]: https://github.com/OpenXiangShan/XiangShan.git

---

ylikou处理器是mesy ISA在本工程的实现。主要部分原型是[`ucb-bar/riscv-mini`][1]，但也参考了[`OpenXiangShan/XiangShan`][2]的Cache实现。

ylikou使用Chisel3库实现。Chisel3是Scala语言下的用于硬件设计的库，提供了很多内置的硬件模块。但ylikou尽量少使用这些模块，因为ylikou最终需要用红石电路实现，即精确到门级建模。

ylikou与[riscv-mini][1]一样是三段流水线设计，即取指，执行，写回三个阶段。不同于MIPS ISA，ylikou的分支、访存指令没有延迟槽。ylikou在执行分支、访存指令时，通过插入空泡阻塞流水线。ylikou只有哈佛结构的L1 Cache，Cache与内存通过[syndesmos协议](../syndesmos)交互。

# 2. 取指

ylikou的取指阶段非常简单，包括以下微步骤：

1. 取指目标生成器根据当前机器状态选择指令地址，取指目标来源一般有：
   1. $pc+4$（绝大部分情况）
   2. $pc$（插入空泡）
   3. $tvec$（发生陷阱时）
   4. $epc$（陷阱返回时）
   5. $ALU$（跳转时）
2. 将取指目标传输至\$1i，同时更新$pc$。指令将在下一阶段返回

# 3. 执行

ylikou在执行阶段完成了尽可能多的工作。这些工作都通过组合逻辑电路实现：

1. 指令从\$1i返回，进行译码
2. 根据寄存器地址读源寄存器，或根据指令提取立即数
3. 根据源寄存器地址检测数据冒险。若存在冒险则使用旁路数据
4. 根据指令进行相应计算：
   1. ALU计算，包括普通计算指令、控制转移地址计算、访存地址计算等
   2. 分支条件判断

# 4. 写回

写回阶段用于写回数据。此处有一条数据旁路通向ALU。

# 5. 访存

访存阶段只在执行访存指令或CSR指令时存在。准备工作都在执行阶段完成，包括访存地址的计算，根据访存地址和数据长度调整数据格式。访存阶段主要负责读出数据的处理，即根据访存地址和数据长度调整数据格式。对CSR指令，指令被送入CSR单元的内部译码器。

# 6. 缓存

ylikou只有一级Cache，采用哈佛结构。每个Cache均为4KB，采用直接映射，块大小16B。

Cache内部分为多个执行单元，负责实现不同的任务。每个执行单元使用状态机实现。

## 6.1. 存储单元

实际存储数据及元数据的组件。数据存储单元为4KB，分为16体。元数据包括20位tag，2位权限位和1位脏位。

## 6.2. 控制单元

控制单元实现了主要的控制逻辑。控制单元的请求源按优先级由高到低排序分别是Probe单元，Miss单元和CPU。所有请求都需要读取存储单元。随后，控制单元根据命中情况向不同的执行单元发送请求。

### 6.2.1. CPU读写请求控制流程

1. 控制单元接受请求，读存储单元
2. 根据命中情况执行不同操作：
   - 命中。直接返回读出的数据，流程结束
   - 不命中。向Miss单元发送不命中请求
3. Miss单元向CPU返回新数据

### 6.2.2. Miss单元replace请求控制流程

1. 控制单元接受请求，读存储单元
2. 向Release单元发送replace请求
3. 向Miss单元发送应答

### 6.2.3. Probe单元probe请求控制流程

1. 控制单元接受请求，读存储单元
2. 修改元数据标识位
3. 向Release单元发送probe请求

## 6.3. Probe单元

Probe单元接受来自B通道的probe请求，并将协议请求翻译为Cache内部请求，发送至控制单元。

## 6.4. Miss单元

Miss单元接受来自控制单元的不命中请求。发生不命中时，Miss单元向下级发送acquire请求获取新数据。若有需要替换的脏数据，则向控制单元发送replace请求。当所有请求的操作完成后，Miss单元向重填单元发送重填请求。

## 6.5. 重填单元

重填单元负责将从Miss单元返回的新数据重填至存储单元。重填时可能与控制单元发生冲突，此时重填具有更高优先级。

## 6.6. Release单元

Release单元负责接受内部的probe和replace请求，将相应旧数据通过协议写回下级存储器。
