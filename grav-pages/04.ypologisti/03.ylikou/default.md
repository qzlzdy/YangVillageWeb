---
title: ylikou处理器
---

- [1. ylikou处理器](#1-ylikou处理器)
- [2. 实现规范](#2-实现规范)
  - [2.1. 允许使用的运算符](#21-允许使用的运算符)
    - [2.1.1. 基本门电路](#211-基本门电路)
    - [2.1.2. 规约运算符](#212-规约运算符)
    - [2.1.3. 比较运算符](#213-比较运算符)
    - [2.1.4. 其他运算符](#214-其他运算符)
  - [2.2. 允许使用的模块](#22-允许使用的模块)
    - [2.2.1. 寄存器](#221-寄存器)
    - [2.2.2. 数据选择器](#222-数据选择器)
    - [2.2.3. 位操作模块](#223-位操作模块)
    - [2.2.4. 存储器](#224-存储器)
    - [2.2.5. 工程提供的模块](#225-工程提供的模块)
    - [2.2.6. 其他模块](#226-其他模块)
- [3. 取指](#3-取指)
- [4. 执行](#4-执行)
- [5. 写回](#5-写回)
- [6. 访存](#6-访存)
- [7. 缓存](#7-缓存)
  - [7.1. 存储单元](#71-存储单元)
  - [7.2. 控制单元](#72-控制单元)
    - [7.2.1. CPU读写请求控制流程](#721-cpu读写请求控制流程)
    - [7.2.2. Miss单元replace请求控制流程](#722-miss单元replace请求控制流程)
    - [7.2.3. Probe单元probe请求控制流程](#723-probe单元probe请求控制流程)
  - [7.3. Probe单元](#73-probe单元)
  - [7.4. Miss单元](#74-miss单元)
  - [7.5. 重填单元](#75-重填单元)
  - [7.6. Release单元](#76-release单元)

# 1. ylikou处理器

原型：[riscv-mini][1]、[Xiangshan][2]

实现语言：[Chisel3](https://www.chisel-lang.org/)

[1]: https://github.com/ucb-bar/riscv-mini.git
[2]: https://github.com/OpenXiangShan/XiangShan.git

---

ylikou处理器是mesy ISA在本工程的实现。主要部分原型是[`ucb-bar/riscv-mini`][1]，但也参考了[`OpenXiangShan/XiangShan`][2]的Cache实现。

ylikou与[riscv-mini][1]一样是三段流水线设计，即取指，执行，写回三个阶段。不同于MIPS ISA，ylikou的分支、访存指令没有延迟槽。ylikou在执行分支、访存指令时，通过插入空泡阻塞流水线。ylikou只有哈佛结构的L1 Cache，Cache与内存通过[syndesmos协议](../syndesmos)交互。

# 2. 实现规范

ylikou使用Chisel3库实现。Chisel3是Scala语言下的用于硬件设计的库，提供了很多内置的硬件模块。但ylikou尽量少使用这些模块，因为ylikou最终需要用红石电路实现，即精确到门级建模。本章给出一些在实现中允许使用的运算符和模块，以及其门级实现（如果有的话）。

## 2.1. 允许使用的运算符

### 2.1.1. 基本门电路

所有的硬件电路最终都需要使用基本门电路实现。本工程中允许使用的门包括与门`&`、或门`|`、非门`~`和异或门`^`。

!!! 尽管理论上最少只用一种门就可以具备图灵完备性，但为了实现简单，工程选用了上述四种常用的逻辑门做为最小的电路单元。

### 2.1.2. 规约运算符

规约操作实际上就是将数据中的所有位做为单一基本门电路的输入，产生$1$位结果。本工程中允许使用的规约操作有`andR`，`orR`和`xorR`。

### 2.1.3. 比较运算符

本工程中允许使用的比较运算符有`===`和`=/=`。

|运算符|门级实现|描述|
|:--|:--|:--|
|`a === b`|`~|(a ^ b)`|相等|
|`a =/= b`|`|(a ^ b)`|不相等|

### 2.1.4. 其他运算符

除了上述允许使用的运算符以外，其他运算符均因为不同的原因**不允许**使用。

- 算术操作`+`，`-`，`*`，`/`和`%`需要专用的运算部件
- 移位操作`<<`，`>>`需要移位器
- 比较操作`<`，`>`，`<=`和`>=`需要算术运算

!!! 为了减少工程量，上述运算只在ALU中实现。

## 2.2. 允许使用的模块

### 2.2.1. 寄存器

基本门电路是组合逻辑电路的基础，而寄存器是时序数字电路的基础。因此，工程将寄存器作为基本的电路模块，包括所有`Reg*`模块。

### 2.2.2. 数据选择器

基本的数据选择器`Mux`在工程中作为基本模块使用。为了编码方便，工程也允许使用`MuxCase`，`MuxLookup`和`PriorityMux`等可传入`Seq`类型信号的数据选择器。

仲裁器`Arbiter`本质上也是一种优先级数据选择器，因此也允许使用。

!!! 用于onehot编码的`Mux1H`的实现可以参考[`riscv-mcu/e203_hbirdv2`](https://github.com/riscv-mcu/e203_hbirdv2)

### 2.2.3. 位操作模块

工程允许使用`Fill`，`Cat`，`Reverse`等可以直接通过连线实现的函数。为了编码方便，当数据宽度不大（$\le4$）时，允许使用`UIntToOH`等编码转换模块。

### 2.2.4. 存储器

存储器在红石电路中可以实现为寄存器阵列。工程允许使用同步读存储器`SyncReadMem`和异步读存储器`Mem`。

### 2.2.5. 工程提供的模块

本工程中提供了若干标准库替换模块。

|模块|描述|
|:--|:--|
|`plus1`|加$1$。用于计数器的实现，包括程序计数器`PC`|
|`Counter`|计数器。对于数据低于$4$位的计数可以使用标准库|

### 2.2.6. 其他模块

除了上述允许使用的模块以外，其他模块**不允许**直接使用。

# 3. 取指

ylikou的取指阶段非常简单，包括以下步骤：

1. 取指目标生成器根据当前机器状态选择指令地址，取指目标来源一般有：
   1. $pc+4$（绝大部分情况）
   2. $pc$（插入空泡）
   3. $tvec$（发生陷阱时）
   4. $epc$（陷阱返回时）
   5. $ALU$（跳转时）
2. 将取指目标传输至`L1i`，同时更新$pc$。指令将在下一阶段返回

# 4. 执行

ylikou在执行阶段完成了尽可能多的工作。这些工作都通过组合逻辑电路实现：

1. 指令从`L1i`返回，进行译码
2. 根据寄存器地址读源寄存器，或根据指令提取立即数
3. 根据源寄存器地址检测数据冒险。若存在冒险则使用旁路数据
4. 根据指令进行相应计算：
   1. `ALU`计算，包括普通计算指令、控制转移地址计算、访存地址计算等
   2. 分支条件判断

# 5. 写回

写回阶段用于写回数据。此处有一条数据旁路通向`ALU`。

# 6. 访存

访存阶段只在执行访存指令或CSR指令时存在。准备工作都在执行阶段完成，包括访存地址的计算，根据访存地址和数据长度调整数据格式。访存阶段主要负责读出数据的处理，即根据访存地址和数据长度调整数据格式。对CSR指令，指令被送入CSR单元的内部译码器。

# 7. 缓存

ylikou只有一级Cache，采用哈佛结构。每个Cache均为$4KB$，采用直接映射，块大小$16B$。

Cache内部分为多个执行单元，负责实现不同的任务。每个执行单元使用状态机实现。

## 7.1. 存储单元

实际存储数据及元数据的组件。数据存储单元为$4KB$，分为$16$体。元数据包括$20$位`tag`，$2$位权限位和$1$位脏位。

## 7.2. 控制单元

控制单元实现了主要的控制逻辑。控制单元的请求源按优先级由高到低排序分别是Probe单元，Miss单元和CPU。所有请求都需要读取存储单元。随后，控制单元根据命中情况向不同的执行单元发送请求。

### 7.2.1. CPU读写请求控制流程

1. 控制单元接受请求，读存储单元
2. 根据命中情况执行不同操作：
   - 命中。直接返回读出的数据，流程结束
   - 不命中。向Miss单元发送不命中请求
3. Miss单元向CPU返回新数据

### 7.2.2. Miss单元replace请求控制流程

1. 控制单元接受请求，读存储单元
2. 向Release单元发送`replace`请求
3. 向Miss单元发送应答

### 7.2.3. Probe单元probe请求控制流程

1. 控制单元接受请求，读存储单元
2. 修改元数据标识位
3. 向Release单元发送`probe`请求

## 7.3. Probe单元

Probe单元接受来自B通道的`probe`请求，并将协议请求翻译为Cache内部请求，发送至控制单元。

## 7.4. Miss单元

Miss单元接受来自控制单元的不命中请求。发生不命中时，Miss单元向下级发送`acquire`请求获取新数据。若有需要替换的脏数据，则向控制单元发送`replace`请求。当所有请求的操作完成后，Miss单元向重填单元发送重填请求。

## 7.5. 重填单元

重填单元负责将从Miss单元返回的新数据重填至存储单元。重填时可能与控制单元发生冲突，此时重填具有更高优先级。

## 7.6. Release单元

Release单元负责接受内部的`probe`和`replace`请求，将相应旧数据通过协议写回下级存储器。
